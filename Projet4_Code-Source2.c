
/*Projet4.*/
/*Ecrire un programme permettant aux processus de faire circuler entre eux un message. 
En fait, le processus principal initialise la variable message à 10 puis il fait passer le message au processus suivant. 
Ensuite, chaque processus fait passer le message au processus d’après de manière à ce que le message fasse le tour de l’anneau. 
À chaque passage du message, au niveau du processus principal, celui-ci décrémente la valeur du message. 
Lorsque le message atteint la valeur 0, les processus transmettent une dernière fois le message avant de s’arrêter.*/
/*@mahahanafi*/
#include<sys/types.h>
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include <sys/wait.h>
#include <stdarg.h>


////debugging information to a file
void printLog(const char *fp, ...)
{
  
  FILE* pFile = fopen("file1.txt", "a");
  if(pFile != NULL)
  {
    va_list ap;
    va_start(ap, fp);
    vfprintf(pFile, fp, ap);
    va_end(ap);
    fclose(pFile);
  }
}

int main(int argc, char const *argv[]) {

//initialisation des variables 
  pid_t pid;
  int n,i,j,status;
  int message;

  
  
  int nbProcessus = 4;
  int p[nbProcessus][2]; //initialisation de la pipe
  
  //le programme commence avec processus 
  printLog("On a %d Processus \n", nbProcessus);
  //creation des pipes 
  for(j = 0; j < nbProcessus; j++)
    pipe(p[j]); 

  printLog("les pipes sont crees \n");

  for ( i = 0; i < nbProcessus; i++) 
  {

    printLog("Processus: %d \n",i);
    
        //creation des processus
        pid =fork();

        if(pid == -1)
        {
            printLog("Error Fork\n");
            exit(2);
        }
      //fils
        else if (pid == 0) 
        {
      printLog("Processus: %d : Fils: %d , Pere: %d \n",i,getpid(),getppid());

      int left = i;//pipe de gauche 
      int right = (i+1)%nbProcessus;//pipe du droit 

      printLog("Processus Fils %d :%d , pipe du gauche: %d et pipe du droit: %d \n",i,getpid(),left,right);
  
      dup2(p[left][0],0); //redirection de l'entrée vers la pipe de gauche  
      dup2(p[right][1],1); //redirection de la sortie vers la pipe de droit
      
      //le processus 0 initialise la circulation du message /***
      if(i==0)
      {
        message = 10; 
        printLog("Processus %d: %d commence avec le message: %d \n",i,getpid(),message);
        write(1,&message, sizeof(int)); //l'ecriture du message 
        printLog("Processus %d :%d envoie le message: %d\n",i,getpid(),message);
      }
  
      while(1)
      {
        //blockage de l'ecriture 
        printLog("Processus %d : %d en train d attendre le message\n",i,getpid());
        //la la lecture de message
        read(0, &message, sizeof(int)); 
        printLog("Processus %d : %d recoit ce message: %d\n",i,getpid(),message);

        
        if(message <= 0)
        {
          printLog("Processus %d : %d termine avec ce message; %d\n",i,getpid(),message);
          write(1, &message, sizeof(int));
          printLog("Processus %d : %d termine et envoie ce dernier message: %d\n",i,getpid(),message); 
          
            exit(0);  
        }
        
        //incrementation si le message <=0
        message--;

        
        write(1, &message, sizeof(int));
        printLog("Processus %d: %d en voie ce message: %d\n",i,getpid(),message);     
      }
    }
    
  }

  printLog("Processus pere %d en train d attendre le fils a termine\n",i,getpid());
//terminaison des processus 
  for ( i = 0; i < n; i++) 
    wait(&status);

  printLog("Processus pere %d termine ce programme \n",i,getpid());

  return 0;
}