#include <stdio.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>
#include <unistd.h>
#include <stdlib.h>
#include <semaphore.h>
#define SKEY   (key_t) IPC_PRIVATE
#define IFLAGS (SEMPERM | IPC_CREAT)
#define SEMPERM 0600
 

int NbPaniersRestant;
int NbCabinesRestant;
 
int j;
int semid;
 
struct sembuf sem_oper_P ;  
struct sembuf sem_oper_V ;  
 
int initsem(key_t semkey)
{
 
    int status = 0;
    int semid_init;
    // Quand plusieurs sémaphores
    union semun { 
        int val;
        struct semid_ds *stat;
        unsigned short * array;
    } ctl_arg;
 
 //creation des commentaires
    if ((semid_init = semget(semkey, 2, IFLAGS)) > 0) {  
 
        unsigned short array[2] = {2, 3};   // Initialisation du nombre de cabines et du nombre de paniers
        ctl_arg.array = array;
        status = semctl(semid_init, 0, SETALL, ctl_arg);    // initialisation en utilisant la structure ctl_arg
    }
 
    if (semid_init == -1 || status == -1) {
        perror("Erreur initsem");
        return (-1);
    } else return (semid_init);
}
 
int P(int semnum){
 
    union semun {  
        int val;
        struct semid_ds *buf;
        ushort * array;
    } arg;
 
    sem_oper_P.sem_num = semnum;
    sem_oper_P.sem_op = -1;
    sem_oper_P.sem_flg = 0 ;
    semop(semid, &sem_oper_P , 1);
 
 
    if (semnum == 1)    // RAPPORT AU NOMBRE DE PANIERS
    {
        NbPaniersRestant = semctl(semid, semnum, GETVAL, arg);
        // printf("NbPaniersRestant %d\n", NbPaniersRestant);
        if (NbPaniersRestant < 0)
        {
            printf("Plus de paniers pour les baigneurs\n");
        }
        else{
            // printf("NbPaniers : %d \n", NbPaniersRestant);
        }
    }
 
    if (semnum == 0)    // RAPPORT AU NOMBRE DE CABINES
    {
        NbCabinesRestant = semctl(semid, semnum, GETVAL, arg);
        if (NbCabinesRestant < 0)
        {
            printf("Plus de cabines pour les baigneurs\n");
        }
        // printf("NbCabines : %d \n", NbCabinesRestant);
    }
 
    return 0;
}
 
/* OPERATION V */
 
int V(int semnum){
 
    union semun {
        int val;
        struct semid_ds *buf;
        ushort * array;
    } arg;
 
    sem_oper_P.sem_num = semnum;
    sem_oper_P.sem_op = +1;
    sem_oper_P.sem_flg = 0 ;
    semop(semid, &sem_oper_P , 1);
 
 
    if (semnum == 1)    // RAPPORT AU NOMBRE DE PANIERS
    {
        NbPaniersRestant = semctl(semid, semnum, GETVAL, arg);
        if (NbPaniersRestant < 0)
        {
            printf("Plus de paniers pour les baigneurs\n");
        }
        else{
            // printf("NbPaniers : %d \n", NbPaniersRestant);
        }
    }
 
    if (semnum == 0)    // RAPPORT AU NOMBRE DE CABINES
    {
        NbCabinesRestant = semctl(semid, semnum, GETVAL, arg);
        if (NbCabinesRestant < 0)
        {
            printf("Plus de cabines pour les baigneurs\n");
        }
        // printf("NbCabines : %d \n", NbCabinesRestant);
    }
 
    return 0;
}
 
void baigneur(int j){
 
    /* LES BAIGNEURS ARRIVE */
    printf("Le baigneur %d ARRIVE \n\n", j);
 
    /* UN BAIGNEUR PREND UN PANIER */
    printf("Le baigneur %d PREND un PANIER \n\n", j);
    P(1);
 
    /* UN BAIGNEUR PREND UNE CABINE */
    printf("Le baigneur %d PREND une CABINE \n\n", j);
    P(0);
 
    /* SE CHANGER */
    printf("Le baigneur %d SE CHANGE \n\n", j);
    usleep(rand()%500);
 
    /* UN BAIGNEUR SE BAIGNE */
    printf("Le baigneur %d se baigne \n\n", j);
    usleep(rand()%5000000);
 
    /* UN BAIGNEUR REND LA CABINE */
    printf("Le baigneur %d REND sa CABINE \n\n", j);
    V(0);
 
    /* UN BAIGNEUR REND LE PANIER */
    printf("Le baigneur %d REND SON PANIER \n\n", j);
    V(1);
 
    /* LES BAIGNEURS S'EN VONT */
    printf("Le baigneur %d PART \n\n", j);
 
    exit(0);
}
 
 
/* PROGRAMME PRINCIPALE */
 
int main(int argc, char **argv)
{
    pid_t pidFils[5];
    int i;
 
    if ((semid = initsem(SKEY)) < 0) // Création de sémaphores (valeur de retour dans semid)
        return(1);
 
    for (i=0; i<5; i++) {
        pid_t pid = fork();
        if  (pid ==0) {
            baigneur(i);
        } else {
            pidFils[i] = pid;
        }
    }
 
    for (i=0; i<5; i++) {
        int status;
        waitpid(pidFils[i], &status, 0);
        // printf("pidFils[%d] = %d (%d)\n", i, pidFils[i], status);
    }
    return 0;
}